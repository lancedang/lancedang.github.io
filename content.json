{"meta":{"title":"拍拍贷中间件团队博客","subtitle":null,"description":"致力于成为中国第一，世界一流的中间件技术团队","author":"dangdang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"SpringBoot 测试-Web层","slug":"SpringBoot 测试-Web层","date":"2018-01-08T03:07:31.219Z","updated":"2018-01-08T03:07:17.923Z","comments":true,"path":"2018/01/08/SpringBoot 测试-Web层/","link":"","permalink":"http://yoursite.com/2018/01/08/SpringBoot 测试-Web层/","excerpt":"","text":"项目环境 SpringBoot project Controller 层的测试 SpringBoot test 涉及的几个方面 如何在 test 环境下引入/创建 SpringBoot 的 application context，如需要某个 controller 的 bean 要不要/及如何开启 Tomcat 服务器来验证实际Http请求，Controller层的测试可以不开启server吗，如果不开启如何测 开启Tomcat和将所有组件全部注入开销较大，有没有方式针对特定Controller所需bean 进行初始化 full Spring application context 和 特定 application context 的概念 Service 和 Dao 要不要依存在 Tomcat/mysql 下来测试 Controller/Service/Dao 分层测试 VS 集成测试 前提 最开始几个例子 都不涉及 组件依赖，即 @controller 没有 autowire @Service 组件 后面会涉及 依赖注入的问题 代码pom 依赖1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Controller123456789@RestController@RequestMappingpublic class BookController &#123; @RequestMapping(&quot;/books&quot;) public String book() &#123; System.out.println(&quot;controller&quot;); return &quot;book&quot;; &#125;&#125; Test1 引入Spring上下文，但不启动tomcat12345678910111213@RunWith(SpringRunner.class)@SpringBootTest //引入Spring上下文 -&gt; 上下文中的 bean 可用，自动注入public class BookControllerTest &#123; @Autowired private BookController bookController; //自动注入 @Test public void testControllerExists() &#123; Assert.assertNotNull(bookController); &#125; &#125; 解释 @SpringBootTest 告知Spring boot寻找main configuration class(主要配置类) 默认是 @SpringBootApplication 所修饰的类 通过该主类 start Spring Application Context bean 可以注入 Spring 提供的测试支持可以将 Application Context 缓存起来，这会使同一个配置类下的上下文资源在不同test case 间共享，所有测试只会产生一次启动应用的开销 @Autowired 注解的bean 在 测试方法运行前被注入 运行测试，通过 console 可以看到没有 Tomcat 的日志打出，Tomcat server未启动 Test2 引入Spring上下文，且启动Tomcat 模拟生产环境，接收Http请求12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) //RANDOM_PORT 启动Tomcatpublic class BookControllerTest &#123; @LocalServerPort private int port; @Autowired private TestRestTemplate testRestTemplate; @Test public void testBook() &#123; Assert.assertEquals(this.testRestTemplate.getForObject(&quot;http://localhost:&quot; + port + &quot;/books&quot;, String.class), &quot;book&quot;); &#125; &#125; 解释 webEnvironment=RANDOM_PORT 启动一个随意端口的Tomcat @LocalServerPort 自动注入随机端口 @TestRestTemlpate Spring boot 提供一个TestRestTemplate，作为 Http Client 存在启动Tomcat的开销 Test3 引入Spring上下文，不启动Tomcat, 由 MockMVC 发送请求123456789101112131415161718@RunWith(SpringRunner.class)@SpringBootTest @AutoConfigureMockMvc //启动自动配置MockMVCpublic class BookControllerTest &#123; @Autowired private MockMvc mockMvc; //只需 autowire @Test public void testBook2() throws Exception &#123; this.mockMvc.perform(get(&quot;/books&quot;)) .andExpect(status().is(200)) .andDo(MockMvcResultHandlers.print()) .andExpect(content().string(&quot;book&quot;)) .andReturn(); &#125; &#125; 解释 @AutoConfigureMockMvc 启动自动配置 MockMvc mockmvc可执行 http client 的功能 print 打印 mock http 详细信息 console 没有打印 Tomcat日志信息，Tomcat 不启动 full Spring application context is started Test4 只引入Web 层 的Spring上下文，不启动Tomcat, 由 MockMVC 发送请求123456789101112131415161718192021222324@RunWith(SpringRunner.class)//@SpringBootTest //full Spring application context@WebMvcTestpublic class BookControllerTest &#123; @Autowired private MockMvc mockMvc; //只需 autowire @Autowired //可以正常注入 private BookController bookController; //@Autowired //另建@Service BookService 类，编译通过，但test运行时异常，不能注入 web 层以外的 bean private BookService bookService; @Test public void testBook2() throws Exception &#123; this.mockMvc.perform(get(&quot;/books&quot;)) .andExpect(status().is(200)) .andDo(MockMvcResultHandlers.print()) .andExpect(content().string(&quot;book&quot;)) .andReturn(); &#125; &#125; 解释 @WebMvcTest 和 @SpringBootTest 性质一样，都是为了start 应用上下文 @WebMvcTest 只能 启动 web 层的上下文 能初始化：@Controller, @ControllerAdvice, @JsonComponent Filter, WebMvcConfigurer and HandlerMethodArgumentResolver beans 不能初始化： @Component, @Service or @Repository beans 还能初始化： Spring Security and MockMvc @SpringBootTest 可以启动所有上下文，资源开销不一样 Test5 只引入Web 层 特定Controller 的Spring上下文，不启动Tomcat, 由 MockMVC 发送请求1234567891011121314151617181920212223@RunWith(SpringRunner.class)@WebMvcTest(BookControler.class) //明确指定引入的 哪个web controller 上下文public class BookControllerTest &#123; @Autowired private MockMvc mockMvc; //只需 autowire @Autowired //可以正常注入 private BookController bookController; //@Autowired //另建@RestController BookController2 类，编译通过，但test运行时异常，不能注入 Book Controller以外的 bean private BookController2 BookController2; @Test public void testBook2() throws Exception &#123; this.mockMvc.perform(get(&quot;/books&quot;)) .andExpect(status().is(200)) .andDo(MockMvcResultHandlers.print()) .andExpect(content().string(&quot;book&quot;)) .andReturn(); &#125; &#125; 解释 @WebMvcTest(SthController.class) 未加 class 属性的 时候注入所有 controller, 指明具体controller 则限制注入的对象 资源开销不一样 Test6 前5个例子都未涉及Controller的依赖问题，现在 controller 依赖 service添加service123456@Servicepublic class BookService &#123; //添加 Service 层 public String addBook() &#123; return &quot;book&quot;; &#125;&#125; 更改Controller，注入 service123456789101112@RestController@RequestMappingpublic class BookController &#123; @Autowired private BookService bookService; //注入 依赖 service bean @RequestMapping(&quot;/books&quot;) public String addBook() &#123; return bookService.addBook(); &#125;&#125; Test 6-1 web layer application context12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@WebMvcTest(BookControler.class) //明确指定引入的 哪个web controller 上下文public class BookControllerTest &#123; @Autowired private MockMvc mockMvc; //只需 autowire @MockBean //mock 伪造 一个 bookService bean 否则，上下文环境中不存在，因为指定了 @WebMvcTest，否则应用启动异常 private BookService bookService; @Autowired //可以正常注入 private BookController bookController; @Test public void testBook2() throws Exception &#123; //因为是mock出的bookService //同时为了将测试范围限定在 controller 层，所以将 service 层的调用固定化 //相当于 service 层的逻辑没有测试直接返回一个假定的结果 when(bookService.addBook()).thenReturn(&quot;book&quot;); this.mockMvc.perform(get(&quot;/books&quot;)) .andExpect(status().is(200)) .andDo(MockMvcResultHandlers.print()) .andExpect(content().string(&quot;book&quot;)) .andReturn(); &#125; &#125; Test 6-2 full Spring application context12345678910111213141516171819202122232425@RunWith(SpringRunner.class)@SpringBootTest // 开启 full Spring application context@AutoConfigureMockMvc //启动自动配置MockMVCpublic class BookControllerTest &#123; @Autowired private MockMvc mockMvc; //只需 autowire //@MockBean //不需要伪造 一个 bookService bean 因为上下文环境中存在，因为指定了 @SpringBootTest //private BookService bookService; @Autowired //可以正常注入 private BookController bookController; @Test public void testBook2() throws Exception &#123; this.mockMvc.perform(get(&quot;/books&quot;)) .andExpect(status().is(200)) .andDo(MockMvcResultHandlers.print()) .andExpect(content().string(&quot;book&quot;)) .andReturn(); &#125; &#125; 解释 当存在 组件 依赖时，如何初始化依赖组件的问题 @WebMvcTest(SthController.class)，指定的Controller 若需要其它 依赖，必须 @MockBean 伪造一个 否则，可用 full Spring Application context 参考： http://spring.io/guides/gs/testing-web/ https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html","categories":[],"tags":[]},{"title":"request parm binging in SpringMVC","slug":"request-parm-binging-in-SpringMVC","date":"2018-01-08T03:01:46.000Z","updated":"2018-01-08T03:02:46.287Z","comments":true,"path":"2018/01/08/request-parm-binging-in-SpringMVC/","link":"","permalink":"http://yoursite.com/2018/01/08/request-parm-binging-in-SpringMVC/","excerpt":"","text":"主题 如何在SpringMVC controller中获取请求request 里的参数 request parameter 如何将请求参数绑定到不同的参数对象 如何使用@RequestParam，并且知晓何时不需要该注解 以下案例都是get 请求获取request 参数 且要明白request上的请求参数 都是以String形式pass的，Spring需要做很多中间处理，将String类型的值转成Controller中你设定的目的类型 测试环境 SpringBoot POSTMAN @RequestParam 案例@Requestparam 注解用来建立 方法参数(method param)与请求参数(request param)的对应关系 1. 绑定方法参数与请求参数的对应关系 url: /books?category=java //参数category 不可缺 Controller 代码12345678@RequestMapping(&quot;/books&quot;)//@RequestParam(&quot;category&quot;) 建立 url中 请求参数-category 和 方法参数-cat 之间的对应关系 //注：当请求参数和方法参数同名时，可省略@RequestParam中的value 值-自动绑定public String books(@RequestParam(&quot;category&quot;) String cat) &#123; //bussiness logic sout(&quot;category &quot; + cat) return &quot;book.jsp&quot;;&#125; 2. 自动类型转换当Request Param 不是 String类型如而是 number时，我们可自动将其转成 number类型的 method 参数 url: /books?rate=5&amp;maxprice=150.55 目的：将rate转成int，将 maxprice 转成 BigDecimal 12345678@RequestParam(&quot;category&quot;) //只需直接指定想要转变成的类型，如 rate 为 int，maxprice 为 BigDecimalpublic String books(@RequestParam(&quot;rate&quot;) int rate, @RequestParm(&quot;maxprice&quot;) BigDecimal maxprice) &#123; //bussiness logic sout(&quot;rate &quot; + rate +&quot;, maxprice &quot; + maxprice) return &quot;book.jsp&quot;;&#125; 3. request 参数为日期类型 url: /books?from=2012-01-12 目的：想传递一个日期类型，且controller自动将字符串“2012-01-12” 转成controller方法参数中日期格式 123456789@RequestMapping(&quot;/books&quot;)public String books(@DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam(&quot;from&quot;) LocalDate from) &#123; //首先用 @DateTimeFormat注解，而且是用其中的ISO.DATE做格式转化, DATE 标识：yyyy-MM-dd //再用LocalDate格式做参数，LocalDate 标识：year-month-day //java.util.Date：年 月 日 hh mm ss System.out.println(&quot;from &quot; + from); return &quot;book.jsp&quot;; &#125; 4. request 参数为不必须 url: /books?category=math category 不是必须的123456@RequestMapping(&quot;/books&quot;)public String books(@RequestParam(&quot;category&quot;, required=false) String cat) &#123; //@RequestParam 默认required = true，为false时 该参数不必须 System.out.println(&quot;category &quot; + cat); return &quot;book.jsp&quot;; &#125; 5. request 自带默认值, 用于以下1/2种场景 url1: /books? //输出：history –category 为 null, required 可以为 false url2: /books?category= //输出：history –category 为 null url3: /books?category=”” // 输出：”” 12345@RequestMapping(&quot;/books&quot;)public String books(@RequestParam(&quot;category&quot;, defaultValue=&quot;history&quot;) String cat) &#123; System.out.println(&quot;category &quot; + cat); return &quot;book.jsp&quot;;&#125; 6. @RequestParam 为 List or array url: /books?authors=zhangsi&amp;authors=lisi request 中同名的参数将自动转化成 controller 中的@RequestParam List ,必要时可用 value 属性指定参数名 方法参数写成 String[] 也可以12345@RequestMapping(&quot;/books&quot;)public String books(@RequestParam List&lt;String&gt; authors) &#123; System.out.println(&quot;authors &quot; + authors); return &quot;book.jsp&quot;;&#125; 7. @RequestParam 为 Map，一个 key 对应一个value值 url: /books?category=math&amp;authors=lisi controller 参数在这种情况下不能通过 @RequestParam的 value 指定具体request 参数名 controller参数类型 为 Map 就出现了一个 谁是 Key，谁是Value的问题,这个是自动装配 根据 requet 参数请求顺序，前面的为 key , 后面的为 value12345678@RequestMapping(&quot;/books&quot;)public String books(@RequestParam Map&lt;String, String&gt; book) &#123; System.out.println(&quot;book &quot; + book); return &quot;book.jsp&quot;;&#125;输出：&#123;category=math, authors=lisi&#125; 8. @RequestParam 为MultiValueMap，一个 key 对应一个多个 value 值 url: /books?category=math&amp;authors=lisi&amp;authors=zhangsi 参数同样具有顺序性，第一个为key, 其余同名参数封装为 value1234567@RequestMapping(&quot;/books&quot;)public String books(@RequestParam MultiValueMap&lt;String, List&lt;String&gt;&gt; book ) &#123; System.out.println(&quot;book &quot; + book); return &quot;book.jsp&quot;;&#125;输出：&#123;category=[math], authors=[lisi, zhangsi]&#125; 9. 不声明 @RequestParam url: /books?category=math 默认 request 和 controller 方法参数同名，可省略 @RequestParam12345678@RequestMapping(&quot;/books&quot;)public String books(String category) &#123; System.out.println(&quot;category &quot; + category); return &quot;book.jsp&quot;;&#125;输出：math建议：指明 @RequestParam 10. request 参数为field, 而 controller 参数为 Object url: /books?category=math&amp;author=lisi Object 对象 封装了两个field: category, author 这个转换非常有用，尤其是多request 参数转成封装对象时 注意此时是没有@RequestParam的，有则4001234567891011121314151617public class Box&#123; String category; String author; getter; setter; String toString() &#123; return &quot;category=&quot; + category +&quot;, author=&quot; + author; &#125;&#125;@RequestMapping(&quot;/books&quot;)public String books(Box box ) &#123; System.out.println(&quot;box &quot; + box); return &quot;book.jsp&quot;;&#125;输出：category=math, author=lisi 注意 以上 @RequestMapping 省略掉 method 属性，则说明所匹配的方法 可以接受任何method请求，PUT/GET/DELETE/POST，并非默认为GET 当method 为 PUT/POST/DELTE时，url 中仍可以用”url?name=lisi”形式 传递参数，因为POSTMAN中这些方法没有parameter选项，直接写在url中即可 参考：https://reversecoding.net/spring-mvc-requestparam-binding-request-parameters/#default-test","categories":[],"tags":[]},{"title":"first blog","slug":"first-blog","date":"2018-01-08T02:53:39.000Z","updated":"2018-01-08T02:53:39.083Z","comments":true,"path":"2018/01/08/first-blog/","link":"","permalink":"http://yoursite.com/2018/01/08/first-blog/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-04T11:39:22.135Z","updated":"2018-01-04T11:39:22.135Z","comments":true,"path":"2018/01/04/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}